#pragma once

#include "drake/common/default_scalars.h"
#include "drake/common/drake_copyable.h"
#include "drake/common/eigen_types.h"
#include "drake/geometry/geometry_ids.h"
#include "drake/multibody/tree/multibody_tree_indexes.h"

namespace drake {
namespace multibody {

/**
 A class containing information regarding contact response between two bodies
 including:

    - The pair of bodies that are contacting, referenced by their BodyIndex.
    - A witness point on body A.
    - A witness point on body B.
    - A contact normal pointing into A.
    - A contact point in the world frame.
    - The resulting force on body A.

 @tparam_default_scalar
 */
template <typename T>
class SpeculativeContactInfo {
 public:
  DRAKE_DEFAULT_COPY_AND_MOVE_AND_ASSIGN(SpeculativeContactInfo);
  /**
   Constructs the contact information for a given pair of two colliding bodies.
   @param bodyA_index
     Index that references body A.
   @param bodyB_index
     Index that references body B.
   @param geometryA_id
     Id of geometry on body A.
   @param geometryB_id
     Id of geometry on body B.
   @param p_WAp Position of the witness point P on A, in the world
   frame.
   @param p_WBq Position of the witness point Q on B, in the world
   frame.
   @param nhat_BA_W Contact normal in the world frame, pointing into body A.
   @param p_WC Position of the contact point C in the world frame.
   @param f_AC_W Contact force on body A applied at the contact point C,
   expressed in the world frame W.

   @pre The two body indexes must reference bodies from the same MultibodyPlant.
   Contact values should likewise be generated by the same MultibodyPlant.
   */
  SpeculativeContactInfo(BodyIndex bodyA_index, BodyIndex bodyB_index,
                         geometry::GeometryId geometryA_id,
                         geometry::GeometryId geometryB_id,
                         const Vector3<T>& p_WAp, const Vector3<T>& p_WBq,
                         const Vector3<T>& nhat_BA_W, const Vector3<T>& p_WC,
                         const Vector3<T>& f_AC_W);

  /// Returns the index of body A in the contact pair.
  BodyIndex bodyA_index() const { return bodyA_index_; }

  /// Returns the index of body B in the contact pair.
  BodyIndex bodyB_index() const { return bodyB_index_; }

  /// Returns the id of geometry A in the contact pair.
  geometry::GeometryId geometryA_id() const { return geometryA_id_; }

  /// Returns the id of geometry B in the contact pair.
  geometry::GeometryId geometryB_id() const { return geometryB_id_; }

  /// Returns the position `p_WAp` of the witness point P on the body A, in the
  /// world frame.
  const Vector3<T>& p_WAp() const { return p_WAp_; }

  /// Returns the position `p_WBq` of the witness point Q on the body B, in the
  /// world frame.
  const Vector3<T>& p_WBq() const { return p_WBq_; }

  /// Returns the contact normal `nhat_BA_W`.
  const Vector3<T>& nhat_BA_W() const { return nhat_BA_W_; }

  /// Returns the position `p_WC` of the contact point C in the world frame.
  const Vector3<T>& p_WC() const { return p_WC_; }

  /// Returns the contact force `f_Ap_W` on A at contact point C expressed in
  /// the world frame W.
  const Vector3<T>& f_AC_W() const { return f_AC_W_; }

 private:
  // Index of body A.
  BodyIndex bodyA_index_;
  // Index of body B.
  BodyIndex bodyB_index_;
  // Id of geometry A.
  geometry::GeometryId geometryA_id_;
  // Id of geometry B.
  geometry::GeometryId geometryB_id_;
  // Position of the witness point P on A, in the world frame.
  Vector3<T> p_WAp_;
  // Position of the witness point Q on B, in the world frame.
  Vector3<T> p_WBq_;
  // Contact normal.
  Vector3<T> nhat_BA_W_;
  // Position of the contact point C in the world frame.
  Vector3<T> p_WC_;
  // Contact force on body A applied at the witness point C, expressed in the
  // world frame W.
  Vector3<T> f_AC_W_;
};

}  // namespace multibody
}  // namespace drake

DRAKE_DECLARE_CLASS_TEMPLATE_INSTANTIATIONS_ON_DEFAULT_SCALARS(
    class ::drake::multibody::SpeculativeContactInfo);
